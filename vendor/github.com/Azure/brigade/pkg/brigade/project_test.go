package brigade

import (
	"encoding/json"
	"testing"
)

func TestShortSHA(t *testing.T) {
	// The expect line was generated by the macOS shasum command, which adds
	// a trailing newline. Note truncated at 54 chars.
	str := "I Break For Sea Beasts\n"
	// c635ce8f0388d039ac9a01d60cfb362dbca8e0722000b614bee75e8e3063621f
	expect := "c635ce8f0388d039ac9a01d60cfb362dbca8e0722000b614bee75e"
	if got := shortSHA(str); got != expect {
		t.Fatalf("Expected short SHA\n\t%q, got\n\t%q", expect, got)
	}
}

func TestProjectSecrets(t *testing.T) {
	proj := Project{
		SharedSecret: "wisper",
		Secrets:      map[string]string{"foo": "bar"},
		Repo:         Repo{SSHKey: "noop"},
	}

	data, err := json.Marshal(&proj)
	if err != nil {
		t.Fatal(err)
	}

	var got Project
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}

	if got.SharedSecret != "" {
		t.Error("Project.SharedSecret should not be exported")
	}
	if val, ok := got.Secrets["foo"]; !ok || val != redacted {
		t.Error("Project.Secrets should not be " + redacted)
	}
	if got.Repo.SSHKey != "" {
		t.Error("Project.Repo.SSHKey should not be exported")
	}
}

func TestProjectWorkerConfig(t *testing.T) {
	proj := Project{
		Worker: WorkerConfig{
			Registry:   "deis",
			Name:       "brigade-worker",
			Tag:        "canary",
			PullPolicy: "Always",
		},
	}

	data, err := json.Marshal(&proj)
	if err != nil {
		t.Fatal(err)
	}

	var got Project
	if err := json.Unmarshal(data, &got); err != nil {
		t.Fatal(err)
	}

	if got.Worker.Registry != "deis" {
		t.Errorf("unexpected Project.Worker.Registry: %s != deis", got.Worker.Registry)
	}
	if got.Worker.Name != "brigade-worker" {
		t.Errorf("unexpected Project.Worker.Name: %s != brigade-worker", got.Worker.Name)
	}
	if got.Worker.Tag != "canary" {
		t.Errorf("unexpected Project.Worker.Tag: %s != canary", got.Worker.Tag)
	}
	if got.Worker.PullPolicy != "Always" {
		t.Errorf("unexpected Project.Worker.PullPolicy: %s != Always", got.Worker.PullPolicy)
	}
}
